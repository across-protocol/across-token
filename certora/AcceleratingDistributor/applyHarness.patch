--- ../../contracts/AcceleratingDistributor.sol	2023-01-23 18:58:13.479444800 +0200
+++ 	2023-01-23 19:03:39.828585100 +0200
@@ -18,8 +18,8 @@
  * they only add supported tokens, and that staking token configurations are applied correctly.
  * @dev This contract is inspired by the Synthetix staking contract, and the Ampleforth geyser.
  */
-
-contract AcceleratingDistributor is ReentrancyGuard, Ownable, Multicall {
+// Certora: remove MultiCaller inheritance due to technical issues.
+contract AcceleratingDistributor is ReentrancyGuard, Ownable {
     using SafeERC20 for IERC20;
 
     /**************************************
@@ -336,7 +336,7 @@
      * @param stakedToken The address of the staked token to query.
      * @return uint256 Total base reward per token that will be applied, pro-rata, to stakers.
      */
-    function baseRewardPerToken(address stakedToken) public view returns (uint256) {
+    function baseRewardPerToken(address stakedToken) public view virtual returns (uint256) {
         StakingToken storage stakingToken = stakingTokens[stakedToken];
         if (stakingToken.cumulativeStaked == 0) return stakingToken.rewardPerTokenStored;
 
@@ -355,7 +355,7 @@
      * @param account The address of the user to query.
      * @return uint256 User multiplier, applied to the baseRewardPerToken, when claiming rewards.
      */
-    function getUserRewardMultiplier(address stakedToken, address account) public view returns (uint256) {
+    function getUserRewardMultiplier(address stakedToken, address account) public view virtual returns (uint256) {
         UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[account];
         if (userDeposit.averageDepositTime == 0 || userDeposit.cumulativeBalance == 0) return 1e18;
         uint256 fractionOfMaxMultiplier = ((getTimeSinceAverageDeposit(stakedToken, account)) * 1e18) /
